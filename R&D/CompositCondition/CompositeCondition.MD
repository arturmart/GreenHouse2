Այս համակարգը համադրում է Strategy և Composite ձևանմուշները և նախատեսված է պայմանների ստուգման ու դրանց հիման վրա գործողությունների կատարման համար։

1. Պայմանների ստրատեգիաներ (IConditionStrategy<T>)
Սահմանված է աբստրակտ ինտերֆեյս IConditionStrategy<T>, որն ունի մեկ մեթոդ․

evaluate(const vector<T>& args) → վերադարձնում է bool, այսինքն՝ արդյո՞ք տրված պայմանը ճիշտ է։

Այս ինտերֆեյսը ժառանգում են կոնկրետ ստրատեգիաները (GreaterThan, LessThan, EqualTo, InRange, և այլն), որոնք իրականացնում են համեմատություններ և տրամաբանական ստուգումներ տարբեր տիպերի համար (double, long long, bool)։

2. ConditionContext (պայմանների կոնտեքստ)
Այս դասը հանդիսանում է բոլոր ստրատեգիաների պահոց։ Այն ապահովում է․

Պայման ստուգում ըստ բանալու (check(key, args))։

Տիպերի փոխարկում (convertArgs)։

Ստրատեգիաների գրանցում (addStrategy) և մաքրում (clearStrategies)։

Այս մոտեցմամբ հնարավոր է համակարգին նոր պայմաններ ավելացնել առանց հիմնական կոդի փոփոխության։

3. Composite (կոմպոզիտ)
Composite ձևանմուշը օգտագործվում է պայմանների ծառ կառուցելու համար։

Յուրաքանչյուր Node ունի վերնագիր, պայման, պայմանական արգումենտներ և գործողությունների ցուցակ։

Node-երը կարող են ունենալ զավակներ, ձևավորելով հիերարխիկ ծառ։

executeAll() մեթոդը անցնում է ծառի բոլոր նոդերով, ստուգում պայմանները և կանչում գործողությունները միայն այն դեպքում, երբ պայմանը (և ծնող նոդերի պայմանները) ճիշտ են։

Այս մեթոդը ապահովում է բարդ պայմանների կոմպոզիցիա և հիերարխիկ կատարման տրամաբանություն։

4. Comparison և ConditionParseJson (JSON-ից ստուգման համակարգ)
Կա նաև այլընտրանքային իրագործում՝ Comparison դասը, որտեղ համեմատությունները պահվում են unordered_map<string, function<bool(vector<double>)>> տեսքով։ Սա թույլ է տալիս համեմատության գործողությունները սահմանել լամբդա-ֆունկցիաներով առանց առանձին դաս ստեղծելու։

ConditionParseJson դասը պատասխանատու է JSON ֆայլից պայմանների կարդալու և դրանց վերլուծման համար։ Այսպիսով հնարավոր է արտաքին կոնֆիգուրացիայով ձևավորել պայմանների ծառ։

5. Խնդիրներ ու բարելավումներ

Ներկայիս իրագործման մեջ կա որոշակի կրկնություն․ առանձին պահվում են ստրատեգիաներ double-ի, long long-ի և bool-ի համար։ Ավելի ճկուն լուծում կլինի օգտագործել std::variant<int64_t, double, bool>։

Մեկ այլ խնդիր է հիշողության կառավարումը․ ստրատեգիաները պահվում են raw pointer-ներով։ Պետք է օգտագործել std::unique_ptr, որպեսզի հիշողությունը ավտոմատ մաքրվի։

Composite-ի exe դաշտը պահում է միայն string-եր։ Ավելի ճշգրիտ կլինի սահմանել առանձին Command կառուցվածք, որտեղ կպահվեն անունը և արգումենտները։

Եզրակացություն․
Այս ճարտարապետությունը տրամադրում է պայմանների ստուգման և դրանց հիման վրա գործողությունների կատարման հզոր և ընդլայնվող մեխանիզմ։ Այն համատեղում է Strategy և Composite ձևանմուշները, իսկ JSON ինտեգրացիան ապահովում է արտաքին կոնֆիգուրացիայից համակարգի կառավարման հնարավորությունը։

![Composite Condition](https://github.com/arturmart/GreenHouse2/blob/master/R%26D/CompositCondition/CompositAndConditionArchetecture.png)
